<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>WAF Dashboard</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; background-color: #f8f9fa; color: #212529; }
        .container { max-width: 1400px; margin: 2em auto; padding: 2em; background-color: #fff; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); }
        h1, h2 { border-bottom: 2px solid #dee2e6; padding-bottom: 0.5em; }
        
        /* --- CSS CHO KHU V·ª∞C TH·ªêNG K√ä --- */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5em;
            margin-bottom: 3em;
        }
        .stat-card {
            background-color: #fff;
            padding: 1.5em;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .stat-card .value {
            font-size: 2.5em;
            font-weight: bold;
            margin: 0.2em 0;
        }
        .stat-card .label {
            font-size: 1em;
            color: #6c757d;
        }
        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        /* --- K·∫æT TH√öC CSS TH·ªêNG K√ä --- */

        table { width: 100%; border-collapse: collapse; margin-top: 1em; }
        th, td { padding: 0.75em; text-align: left; border-bottom: 1px solid #dee2e6; font-size: 14px; }
        thead { background-color: #e9ecef; }
        tr:nth-child(even) { background-color: #f8f9fa; }
        .status-blocked { color: #dc3545; font-weight: bold; }
        .status-allowed { color: #28a745; }
        
        /* Category stats styles */
        .category-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 1em;
            margin-bottom: 2em;
        }
        .category-item {
            display: flex;
            align-items: center;
            gap: 0.5em;
            padding: 0.5em 1em;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .category-badge {
            display: inline-block;
            padding: 0.25em 0.6em;
            font-size: 0.75em;
            font-weight: 600;
            line-height: 1;
            color: #fff;
            text-align: center;
            white-space: nowrap;
            vertical-align: baseline;
            border-radius: 0.375rem;
        }
        .category-count {
            font-weight: 500;
            color: #495057;
        }
        .category-sql-injection { background-color: #dc3545; }
        .category-nosql-injection { background-color: #ff6b35; }
        .category-xss { background-color: #fd7e14; }
        .category-bot-protection { background-color: #20c997; }
        .category-path-traversal { background-color: #6f42c1; }
        .category-command-injection { background-color: #e83e8c; }
        .category-file-upload { background-color: #17a2b8; }
        .category-rate-limiting { background-color: #28a745; }
        .category-custom { background-color: #6c757d; }
        .category-injection { background-color: #e83e8c; }
        /* New categories */
        .category-scanner-bot { background-color: #20c997; }              /* t∆∞∆°ng t·ª± Bot Protection */
        .category-protocol-manipulation { background-color: #007bff; }    /* xanh d∆∞∆°ng */
        .category-ssti { background-color: #6f42c1; }                     /* t√≠m */
        .category-lfi-rce { background-color: #343a40; }                  /* x√°m ƒë·∫≠m */
    </style>
</head>
<body>
    <div class="container">
        <h1>WAF Dashboard</h1>

        <div class="stats-grid">
            <div class="stat-card" onclick="resetFilter()" style="cursor: pointer; transition: all 0.3s ease;" title="Show all requests">
                <div class="value">{{ stats.total_requests }}</div>
                <div class="label">üìä T·ªïng s·ªë Requests</div>
            </div>
            <div class="stat-card" onclick="filterByAction('ALLOWED')" style="cursor: pointer; transition: all 0.3s ease;" title="Show allowed requests only">
                <div class="value" style="color: #28a745;">{{ stats.allowed_requests }}</div>
                <div class="label">‚úÖ Requests ƒê∆∞·ª£c Ph√©p</div>
            </div>
            <div class="stat-card" onclick="filterByAction('BLOCKED')" style="cursor: pointer; transition: all 0.3s ease;" title="Show blocked requests only">
                <div class="value" style="color: #dc3545;">{{ stats.blocked_requests }}</div>
                <div class="label">üö´ Requests B·ªã Ch·∫∑n</div>
            </div>
            <a href="/manage-rules" style="text-decoration: none; color: inherit;">
                <div class="stat-card" style="cursor: pointer; transition: all 0.3s ease;">
                    <div class="value" style="color: #007bff;">{{ stats.active_rules }}</div>
                    <div class="label">üõ°Ô∏è Rule ƒêang Ho·∫°t ƒê·ªông</div>
                </div>
            </a>
            <a href="{{ url_for('view_blacklist') }}" class="stat-card" style="text-decoration: none; color: inherit; display: block;">
                <div class="value" style="color: #6c757d;">{{ stats.blacklisted_ips }}</div>
                <div class="label">‚õî IP Trong Blacklist</div>
            </a>
        </div>

        <h2>Rules by Category</h2>
        <div class="category-stats">
            {% for category_stat in stats.category_stats %}
            <div class="category-item">
                <span class="category-badge category-{{ category_stat.category.lower().replace(' ', '-').replace('/', '-') }}">
                    {{ category_stat.category }}
                </span>
                <span class="category-count">{{ category_stat.count }} rules</span>
            </div>
            {% endfor %}
        </div>

        <h2>Activity Log</h2>
        <table>
            <thead>
                <tr>
                    <th>Timestamp</th>
                    <th>Client IP</th>
                    <th>Method</th>
                    <th>Path</th>
                    <th>Action</th>
                    <th>Status Code</th>
                    <th>Triggered Rule</th>
                </tr>
            </thead>
            <tbody>
                {% for log in logs %}
                <tr>
                    <td>{{ log.timestamp | e }}</td>
                    <td>{{ log.client_ip | e }}</td>
                    <td>{{ log.request_method | e }}</td>
                    <td style="word-break: break-all;">{{ log.request_path | e }}</td>
                    <td>
                        <span class="status-{{ log.action_taken.lower() }}">
                            {{ log.action_taken | e }}
                        </span>
                    </td>
                    <td>{{ log.status_code | e }}</td>
                    <td>{{ (log.triggered_rule_id if log.triggered_rule_id is not none else 'N/A') | e }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>

    <script>
        // Store existing log IDs to track what's new
        let existingLogIds = new Set();
        let currentPage = 1;
        let paginationData = {};
        let currentFilter = 'ALL'; // ALL, ALLOWED, or BLOCKED

        // Generate unique log ID from log data
        function getLogId(log) {
            return `${log.timestamp}-${log.client_ip}-${log.request_method}-${log.request_path}-${log.action_taken}-${log.status_code}`;
        }

        // Initialize existing log IDs from current page
        function initializeExistingLogIds() {
            const tbody = document.querySelector('table tbody');
            if (tbody) {
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 6) {
                        const logId = getLogId({
                            timestamp: cells[0].textContent,
                            client_ip: cells[1].textContent,
                            request_method: cells[2].textContent,
                            request_path: cells[3].textContent,
                            action_taken: cells[4].textContent.trim(),
                            status_code: cells[5].textContent
                        });
                        existingLogIds.add(logId);
                    }
                });
            }
        }

        // Professional real-time log updates using AJAX with pagination
        function loadNewLogs() {
            let url = `/api/logs/latest?page=${currentPage}&per_page=100`;
            if (currentFilter !== 'ALL') {
                url += `&action=${currentFilter}`;
            }

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    updateLogTable(data.logs);
                    updateStats(data.stats);
                    updatePaginationControls(data.pagination);
                    updateFilterIndicator();
                })
                .catch(error => {
                    console.error('Error loading new logs:', error);
                });
        }

        // Load specific page
        function loadPage(page) {
            currentPage = page;
            existingLogIds.clear(); // Clear to track new logs on this page
            loadNewLogs();
        }

        // Filter logs by action
        function filterByAction(action) {
            currentFilter = action;
            currentPage = 1; // Reset to first page
            existingLogIds.clear();
            loadNewLogs();
        }

        // Reset filter to show all logs
        function resetFilter() {
            currentFilter = 'ALL';
            currentPage = 1; // Reset to first page
            existingLogIds.clear();
            loadNewLogs();
        }

        // Update filter indicator
        function updateFilterIndicator() {
            let filterText = '';
            if (currentFilter === 'ALLOWED') {
                filterText = ' <span style="color: #28a745; font-weight: bold;">(Allowed Requests Only)</span>';
            } else if (currentFilter === 'BLOCKED') {
                filterText = ' <span style="color: #dc3545; font-weight: bold;">(Blocked Requests Only)</span>';
            }

            const h2 = document.querySelector('h2');
            if (h2) {
                h2.textContent = 'Activity Log' + filterText.replace(/<[^>]*>/g, ''); // Strip HTML tags for textContent
                h2.innerHTML = 'Activity Log' + filterText; // Use innerHTML for styling
            }
        }

        // Update pagination controls
        function updatePaginationControls(pagination) {
            paginationData = pagination;
            let paginationHtml = '';

            if (pagination.total_pages > 1) {
                paginationHtml = '<div class="pagination" style="margin: 20px 0; text-align: center;">';

                // Previous button
                if (pagination.has_prev) {
                    paginationHtml += `<button onclick="loadPage(${pagination.current_page - 1})" style="margin: 0 5px; padding: 5px 10px; border: 1px solid #ddd; background: #fff; cursor: pointer;">Previous</button>`;
                }

                // Page numbers
                const startPage = Math.max(1, pagination.current_page - 2);
                const endPage = Math.min(pagination.total_pages, pagination.current_page + 2);

                for (let i = startPage; i <= endPage; i++) {
                    const isActive = i === pagination.current_page;
                    const style = isActive ? 'margin: 0 5px; padding: 5px 10px; border: 1px solid #007bff; background: #007bff; color: white; cursor: pointer;' : 'margin: 0 5px; padding: 5px 10px; border: 1px solid #ddd; background: #fff; cursor: pointer;';
                    paginationHtml += `<button onclick="loadPage(${i})" style="${style}">${i}</button>`;
                }

                // Next button
                if (pagination.has_next) {
                    paginationHtml += `<button onclick="loadPage(${pagination.current_page + 1})" style="margin: 0 5px; padding: 5px 10px; border: 1px solid #ddd; background: #fff; cursor: pointer;">Next</button>`;
                }

                paginationHtml += '</div>';

                // Add pagination info
                paginationHtml += `<div style="text-align: center; color: #6c757d; font-size: 14px;">`;
                paginationHtml += `Page ${pagination.current_page} of ${pagination.total_pages} (${pagination.total_logs} total logs)`;
                paginationHtml += `</div>`;
            }

            // Update pagination container
            let paginationContainer = document.getElementById('pagination-container');
            if (!paginationContainer) {
                paginationContainer = document.createElement('div');
                paginationContainer.id = 'pagination-container';
                const table = document.querySelector('table');
                if (table) {
                    table.parentNode.insertBefore(paginationContainer, table.nextSibling);
                }
            }
            paginationContainer.innerHTML = paginationHtml;
        }

        // HTML escape function to prevent XSS
        function escapeHtml(unsafe) {
            // Handle null, undefined, and non-string values
            if (unsafe === null || unsafe === undefined) {
                return 'N/A';
            }
            return String(unsafe)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function updateLogTable(newLogs) {
            const tbody = document.querySelector('table tbody');
            if (tbody && newLogs && newLogs.length > 0) {
                // Clear existing logs and rebuild
                tbody.innerHTML = '';

                // Add logs in correct order (newest first)
                newLogs.forEach(log => {
                    const logId = getLogId(log);
                    const isNewLog = !existingLogIds.has(logId);

                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${escapeHtml(log.timestamp)}</td>
                        <td>${escapeHtml(log.client_ip)}</td>
                        <td>${escapeHtml(log.request_method)}</td>
                        <td style="word-break: break-all;">${escapeHtml(log.request_path)}</td>
                        <td>
                            <span class="status-${log.action_taken.toLowerCase()}">
                                ${escapeHtml(log.action_taken)}
                            </span>
                        </td>
                        <td>${escapeHtml(log.status_code)}</td>
                        <td>${escapeHtml(log.triggered_rule_id || 'N/A')}</td>
                    `;

                    // Just track new logs without highlighting
                    if (isNewLog) {
                        existingLogIds.add(logId);
                    }

                    tbody.appendChild(row);
                });
            }
        }

        function updateStats(newStats) {
            if (newStats) {
                // Update all stat card values
                const totalElement = document.querySelector('.stat-card:nth-child(1) .value');
                const allowedElement = document.querySelector('.stat-card:nth-child(2) .value');
                const blockedElement = document.querySelector('.stat-card:nth-child(3) .value');
                const rulesElement = document.querySelector('.stat-card:nth-child(4) .value');
                const blacklistedElement = document.querySelector('.stat-card:nth-child(5) .value');

                if (totalElement) totalElement.textContent = newStats.total_requests;
                if (allowedElement) allowedElement.textContent = newStats.allowed_requests;
                if (blockedElement) blockedElement.textContent = newStats.blocked_requests;
                if (rulesElement) rulesElement.textContent = newStats.active_rules;
                if (blacklistedElement) blacklistedElement.textContent = newStats.blacklisted_ips;
            }
        }

        // Add visual indicator
        document.addEventListener('DOMContentLoaded', function() {
            const header = document.querySelector('h1');
            if (header) {
                const statusIndicator = document.createElement('span');
                statusIndicator.innerHTML = ' <span style="font-size: 0.8em; color: #28a745; font-weight: bold;">‚óè Real-time logs</span>';
                statusIndicator.id = 'refresh-indicator';
                header.appendChild(statusIndicator);

                // Pulse effect for live indicator
                setInterval(() => {
                    statusIndicator.style.opacity = '0.5';
                    setTimeout(() => {
                        statusIndicator.style.opacity = '1';
                    }, 500);
                }, 2000);
            }

            // Initialize existing log IDs from the page
            initializeExistingLogIds();

            // Initial load
            loadNewLogs();

            // Poll for new logs every 3 seconds (only update current page)
            setInterval(() => {
                let url = `/api/logs/latest?page=${currentPage}&per_page=100`;
                if (currentFilter !== 'ALL') {
                    url += `&action=${currentFilter}`;
                }

                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        // Only update if new logs are available
                        if (data.logs && data.logs.length > 0) {
                            updateLogTable(data.logs);
                            updateStats(data.stats);
                            // Don't update pagination controls during auto-refresh to avoid jumping pages
                        }
                    })
                    .catch(error => {
                        console.error('Error loading new logs:', error);
                    });
            }, 3000);
        });
    </script>
</body>
</html>